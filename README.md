# DY2BIT_Server
<img width="1200" alt="image" src="https://user-images.githubusercontent.com/39155520/161865502-135df50a-6918-4fe2-aefd-0244a5e7211a.png">

트레이딩 알고리즘 한달 수동 테스트
- 2월19일 2020만원
- 2월20일 2029만원
- 2월24일 2032만원
- 2월28일 2049만원
- 3월01일 2037만원
- 3월05일 2071만원
- 3월07일 2086만원
- 3월13일 2103만원

## 서버 기획 스펙
### 0. 공통
- 업비트, 바이낸스, 환율 api를 4초 주기로 가격을 받아와 김프가를 계산합니다.
- 해당 김프가를 기준으로 가격 트래킹과 사용자 예약 주문 처리를 진행합니다.
### 1. 가격 트래킹
- 매일 00시 00분에 오늘의 김프가를 생성합니다.
- 공통에서 처리한 김프가를 기준으로 오늘 날짜의 최대, 최소 코인 시세 기록을 자동 저장합니다.(최저가, 최대가 기록을 위한 작업)
### 2. 사용자 예약 주문 처리
- 사용자가 예약 주문을 요청하면 해당 요청을 저장합니다.
- 현재 김프가와 환율도 함께 조회하여 저장합니다.
- 예약 주문된 내역은 프론트에서 볼 수 있도록 리스트로 내려줍니다.
- 공통에서 처리한 김프가를 기준으로 해당 김프 가격에 도달하면 자동으로 업비트와 바이낸스에서 동시에 매매를 진행합니다.
- 매매 당시 에러가 발생하였으면 이후 모든 매매가 중지되고 사용자 어플리케이션에서 확인할 수 있습니다.
### 3. 거래소 로직
- 이하 거래소는 업비트와 바이낸스 모두 포함
- 공통에서 처리된 김프가와 현재 예약 주문에 존재하는 예약 가격을 비교합니다.
- 거래소에서 잔고를 조회하여 예약 주문된 수량이 주문 가능한지 체크함.
- 주문이 가능하다면 거래소별 시장가로 거래함
- 예약 주문 된 수량에서 0.03비트를 빼고 저장함.
- 4초마다 Job이 돌기 때문에 다음 스케줄에서도 조건에 만족하면 주문 수량이 0이 될 때까지 반복함.
- 주문 발생 당시 에러가 검출되면 모든 거래를 막음.

## 주의해야 할 로직 처리
- 조건에 맞는 김프가가 왔을 때 예약 물량을 한번에 거래하지 않고 0.03비트씩 주문 하도록 함.(한번에 호가에 쌓인 물량을 다 긁으면 수익이 줄어들기 때문에 0.03비트씩 거래함)
- 주문 가능 수량은 10프로 증거금을 계산하여 처리함(10프로 증거금은 안전한 거래를 위한 보험용)
- 여러 예약 주문의 목표가에 동시에 도달시에는 가장 가장 오래전에 만들어진 주문을 기준으로 처리함.(동시 처리X)
- 주문 오류가 발생하면 더이상 거래가 이루어지지 않도록 해야함.

## 기술적 고려 사항
- 호출하는 API가 많아 비동기 처리 신경쓰기 (Coroutine)
- 3초~5초마다 DB에 접근하므로 Latancy를 줄여줘야함 (Redis)
- API의 장애를 생각해서 예외처리 잘 해주기

## 기술스택
- Kotlin
- Springboot
- Mysql
- JPA (Hibernate)
- Liquibase
- Coroutine

## DB
엔티티
- DailyPrice(시세저장)
  아이디, 종목명, 최소값, 최대값, 최소값 갱신 시각, 최대값 갱신 시각, 생성일

- ReservationOrder(예약 주문)
  아이디, 종목명, 예약수량, 김프 설정가, 매수or매도(업비트 기준) 여부, 생성일, 종료일(취소 포함)

- Member(로그인)
  아이디, 이메일, 비밀번호

- Error(에러 로깅)
  아이디, 에러발생 거래소, 에러 메세지, 에러 발견 시각, 생성일

## Schedular & Batch Job
- 4초마다 한번씩 업비트, 바이낸스 가격을 불러와 김프 가격을 계산하고 김프를 기준으로 min, max 업데이트, 예약 주문 매매하기 로직을 수행합니다.
- 매일 00시00분에 Tracker 하나씩 추가 (하루동안은 이 Tracker에 업데이트 하는 것)

## 배포전략
- Server: AWS EC2
- Front: AWS Amplify
